/**
 * This is an autogenerated netlist code from CircuitVerse. Verilog Code can be
 * tested on https://www.edaplayground.com/ using Icarus Verilog 0.9.7. This is an
 * experimental module and some manual changes make need to be done in order for
 * this to work.
 *
 * If you have any ideas/suggestions or bug fixes, raise an issue
 * on https://github.com/CircuitVerse/CircuitVerse/issues/new/choose
 */

/*
  Element Usage Report
    Counter - 1 times
    Demultiplexer - 3 times
    OrGate - 9 times
    NotGate - 5 times
    AndGate - 12 times
    DflipFlop - 7 times
    Buffer - 2 times
    TriState - 3 times
    Random - 1 times
    XorGate - 6 times
    DigitalLed - 7 times
    Button - 3 times
    Clock - 1 times
    Input - 3 times
    ConstantVal - 5 times
*/

/*
  Usage Instructions and Tips
    Labels - Ensure unique label names and avoid using verilog keywords
    Warnings - Connect all optional inputs to remove warnings
    Button - Buttons are not natively supported in verilog, consider using Inputs instead
    Clock - Use a single global clock
*/

// Sample Testbench Code - Uncomment to use

/*
module TestBench();

  reg inp_0, inp_1, inp_2, clk_0;


  Main DUT0(clk_0, inp_0, inp_1, inp_2);

  always begin
    #10
    clk_0 = 0;
    #10
    clk_0 = 1;
  end

  initial begin
    inp_0 = 0;
    inp_1 = 0;
    inp_2 = 0;

    #15

    #10

    $finish;

  end
endmodule

*/

module Main(clk_0, inp_0, inp_1, inp_2);
  input inp_0, inp_1, inp_2, clk_0;
  wire Demultiplexer_0_out_0, Demultiplexer_0_out_1, Demultiplexer_0_out_2, Demultiplexer_0_out_3, or_2_out, not_2_out, and_11_out, or_5_out, or_7_out, not_4_out, DflipFlop_6_Q, Buffer_1_out, TriState_0_out, or_8_out, Demultiplexer_2_out_0, Demultiplexer_2_out_1, Demultiplexer_2_out_2, Demultiplexer_2_out_3, Demultiplexer_2_out_4, Demultiplexer_2_out_5, and_10_out, and_9_out, and_8_out, and_7_out, and_6_out, Demultiplexer_1_out_0, Demultiplexer_1_out_1, Demultiplexer_1_out_2, Demultiplexer_1_out_3, Demultiplexer_1_out_4, Demultiplexer_1_out_5, and_5_out, or_4_out, xor_4_out, DflipFlop_2_Q, and_2_out, DflipFlop_3_Q, and_3_out, DflipFlop_4_Q, and_4_out, DflipFlop_5_Q, and_1_out, and_0_out, xor_3_out, or_1_out, not_3_out, xor_2_out, or_0_out, not_1_out, xor_1_out, not_0_out, xor_0_out, No_out, or_3_out, Buffer_0_out, TriState_1_out, DflipFlop_1_Q, DflipFlop_0_Q, xor_5_out, TriState_2_out, or_6_out, Yes_out, Clear_out, const_4, const_3, const_2, const_1, const_0;
  wire [1:0] Counter_0_Value;
  wire [2:0] Random_0_RandomValue;
  Counter #(2) Counter_0(Counter_0_Value, , , TriState_2_out, Clear_out);
  Demultiplexer4 Demultiplexer_0(Demultiplexer_0_out_0, Demultiplexer_0_out_1, Demultiplexer_0_out_2, Demultiplexer_0_out_3, inp_0, Counter_0_Value);
  assign or_2_out = or_1_out | Demultiplexer_0_out_3;
  assign not_2_out = ~or_2_out;
  assign and_11_out = not_2_out & Demultiplexer_2_out_5;
  assign or_5_out = and_6_out | and_7_out | and_8_out | and_9_out | and_10_out | and_11_out;
  assign or_7_out = TriState_0_out | or_5_out;
  assign not_4_out = ~or_7_out;
  DflipFlop DflipFlop_6(DflipFlop_6_Q, , clk_0, not_4_out, , , );
  assign Buffer_1_out = DflipFlop_6_Q;
  assign TriState_0_out = (Buffer_1_out!=0) ? Buffer_1_out : 1'b?;
  assign or_8_out = TriState_2_out | not_4_out;
  Random #(3) Random_0(Random_0_RandomValue, or_8_out, );
  Demultiplexer8 Demultiplexer_2(Demultiplexer_2_out_0, Demultiplexer_2_out_1, Demultiplexer_2_out_2, Demultiplexer_2_out_3, Demultiplexer_2_out_4, Demultiplexer_2_out_5, , , inp_1, Random_0_RandomValue);
  assign and_10_out = not_3_out & Demultiplexer_2_out_4;
  assign and_9_out = not_1_out & Demultiplexer_2_out_3;
  assign and_8_out = not_0_out & Demultiplexer_2_out_2;
  assign and_7_out = const_0 & Demultiplexer_2_out_1;
  assign and_6_out = const_0 & Demultiplexer_2_out_0;
  Demultiplexer8 Demultiplexer_1(Demultiplexer_1_out_0, Demultiplexer_1_out_1, Demultiplexer_1_out_2, Demultiplexer_1_out_3, Demultiplexer_1_out_4, Demultiplexer_1_out_5, , , const_3, Random_0_RandomValue);
  assign and_5_out = Demultiplexer_1_out_5 & DflipFlop_5_Q;
  assign or_4_out = and_0_out | and_1_out | and_2_out | and_3_out | and_4_out | and_5_out;
  assign xor_4_out = No_out ^ or_4_out;
  DflipFlop DflipFlop_2(DflipFlop_2_Q, , TriState_2_out, xor_4_out, Clear_out, , xor_0_out);
  assign and_2_out = Demultiplexer_1_out_2 & DflipFlop_2_Q;
  DflipFlop DflipFlop_3(DflipFlop_3_Q, , TriState_2_out, xor_4_out, Clear_out, , xor_1_out);
  assign and_3_out = Demultiplexer_1_out_3 & DflipFlop_3_Q;
  DflipFlop DflipFlop_4(DflipFlop_4_Q, , TriState_2_out, xor_4_out, Clear_out, , xor_2_out);
  assign and_4_out = Demultiplexer_1_out_4 & DflipFlop_4_Q;
  DflipFlop DflipFlop_5(DflipFlop_5_Q, , TriState_2_out, xor_4_out, Clear_out, , xor_3_out);
  
      always @ (*)
        $display("DigitalLed:or_4_out=%d", or_4_out);
  assign and_1_out = Demultiplexer_1_out_1 & DflipFlop_1_Q;
  assign and_0_out = DflipFlop_0_Q & Demultiplexer_1_out_0;
  assign xor_3_out = not_3_out ^ not_2_out;
  
      always @ (*)
        $display("DigitalLed:not_2_out=%d", not_2_out);
  assign or_1_out = or_0_out | Demultiplexer_0_out_2;
  assign not_3_out = ~or_1_out;
  assign xor_2_out = not_1_out ^ not_3_out;
  
      always @ (*)
        $display("DigitalLed:not_3_out=%d", not_3_out);
  assign or_0_out = Demultiplexer_0_out_0 | Demultiplexer_0_out_1;
  assign not_1_out = ~or_0_out;
  assign xor_1_out = not_0_out ^ not_1_out;
  
      always @ (*)
        $display("DigitalLed:not_1_out=%d", not_1_out);
  assign not_0_out = ~Demultiplexer_0_out_0;
  assign xor_0_out = const_0 ^ not_0_out;
  
      always @ (*)
        $display("DigitalLed:not_0_out=%d", not_0_out);
  Button0 No(No_out);
  assign or_3_out = No_out | Yes_out;
  assign Buffer_0_out = or_3_out;
  assign TriState_2_out = (Buffer_0_out!=0) ? Buffer_0_out : 1'b?;
  DflipFlop DflipFlop_1(DflipFlop_1_Q, , TriState_2_out, const_1, Clear_out, , const_2);
  DflipFlop DflipFlop_0(DflipFlop_0_Q, , TriState_2_out, const_2, Clear_out, , const_2);
  assign xor_5_out = inp_2 ^ TriState_2_out;
  assign TriState_2_out = (xor_5_out!=0) ? or_6_out : 1'b?;
  assign or_6_out = TriState_2_out | const_4;
  Button1 Yes(Yes_out);
  Button2 Clear(Clear_out);
  assign const_4 = 1'b0;
  assign const_3 = 1'b1;
  assign const_2 = 1'b1;
  assign const_1 = 1'b0;
  assign const_0 = 1'b1;
  
      always @ (*)
        $display("DigitalLed:const_0=%d", const_0);
  
      always @ (*)
        $display("DigitalLed:const_0=%d", const_0);
endmodule

    module Counter(val, zero, max, clk, rst);
      parameter WIDTH = 1;
      output reg [WIDTH-1:0] val;
      output reg zero;
      input [WIDTH-1:0] max;
      input clk, rst;
    
      initial
        val = 0;
    
      always @ (val)
        if (val == 0)
          zero = 1;
        else
          zero = 0;
    
      always @ (posedge clk or posedge rst) begin
        if (rst)
          val <= 0;
        else
          if (val == max)
            val <= 0;
          else
            val <= val + 1;
      end
    endmodule
module Demultiplexer4(out0, out1, out2, out3, in, sel);
  parameter WIDTH = 1;
  output reg [WIDTH-1:0] out0, out1, out2, out3;
  input [WIDTH-1:0] in;
  input [1:0] sel;
  
  always @ (*) begin
    out0 = 0;
    out1 = 0;
    out2 = 0;
    out3 = 0;
    case (sel)
      0 : out0 = in;
      1 : out1 = in;
      2 : out2 = in;
      3 : out3 = in;
    endcase
  end
endmodule

module Demultiplexer8(out0, out1, out2, out3, out4, out5, out6, out7, in, sel);
  parameter WIDTH = 1;
  output reg [WIDTH-1:0] out0, out1, out2, out3, out4, out5, out6, out7;
  input [WIDTH-1:0] in;
  input [2:0] sel;
  
  always @ (*) begin
    out0 = 0;
    out1 = 0;
    out2 = 0;
    out3 = 0;
    out4 = 0;
    out5 = 0;
    out6 = 0;
    out7 = 0;
    case (sel)
      0 : out0 = in;
      1 : out1 = in;
      2 : out2 = in;
      3 : out3 = in;
      4 : out4 = in;
      5 : out5 = in;
      6 : out6 = in;
      7 : out7 = in;
    endcase
  end
endmodule

module DflipFlop(q, q_inv, clk, d, a_rst, pre, en);
    parameter WIDTH = 1;
    output reg [WIDTH-1:0] q, q_inv;
    input clk, a_rst, pre, en;
    input [WIDTH-1:0] d;

    always @ (posedge clk or posedge a_rst)
    if (a_rst) begin
        q <= 'b0;
        q_inv <= 'b1;
    end else if (en == 0) ;
    else begin
        q <= d;
        q_inv <= ~d;
    end
endmodule
    
      module Random(val, clk, max);
        parameter WIDTH = 1;
        output reg [WIDTH-1:0] val;
        input clk;
        input [WIDTH-1:0] max;
      
        always @ (posedge clk)
          if (^max === 1'bX)
            val = $urandom_range(0, {WIDTH{1'b1}});
          else
            val = $urandom_range(0, max);
      endmodule
      // Skeleton for Button0
    /*
    module Button0(out);
      output reg out;
    
      initial begin
        //do something with the button here
      end
    endmodule
    */
    // Skeleton for Button1
    /*
    module Button1(out);
      output reg out;
    
      initial begin
        //do something with the button here
      end
    endmodule
    */
    // Skeleton for Button2
    /*
    module Button2(out);
      output reg out;
    
      initial begin
        //do something with the button here
      end
    endmodule
    */
    